'use strict';

var _objectWithoutPropertiesLoose = require('@babel/runtime/helpers/objectWithoutPropertiesLoose');
var _extends = require('@babel/runtime/helpers/extends');
var React = require('react');
var reactDom = require('react-dom');
var reactPopper = require('react-popper');

const TooltipContext = React.createContext({}); // eslint-disable-next-line @typescript-eslint/no-explicit-any

// eslint-disable-next-line @typescript-eslint/no-explicit-any
const callAll = (...fns) => (...args) => fns.forEach(fn => fn && fn(...args));
const noop = () => {// do nothing
};
const canUseDOM = () => !!(typeof window !== 'undefined' && window.document && window.document.createElement);
const setRef = (ref, node) => {
  if (typeof ref === 'function') {
    return ref(node);
  } else if (ref != null) {
    ref.current = node;
  }
};

class Tooltip extends React.Component {
  constructor(...args) {
    super(...args);
    this.observer = void 0;
    this.tooltipRef = void 0;

    this.handleOutsideClick = event => {
      if (this.tooltipRef && !this.tooltipRef.contains(event.target)) {
        const parentOutsideClickHandler = this.context.parentOutsideClickHandler;
        const _this$props = this.props,
              hideTooltip = _this$props.hideTooltip,
              clearScheduled = _this$props.clearScheduled;
        clearScheduled();
        hideTooltip();

        if (parentOutsideClickHandler) {
          parentOutsideClickHandler(event);
        }
      }
    };

    this.handleOutsideRightClick = event => {
      if (this.tooltipRef && !this.tooltipRef.contains(event.target)) {
        const parentOutsideRightClickHandler = this.context.parentOutsideRightClickHandler;
        const _this$props2 = this.props,
              hideTooltip = _this$props2.hideTooltip,
              clearScheduled = _this$props2.clearScheduled;
        clearScheduled();
        hideTooltip();

        if (parentOutsideRightClickHandler) {
          parentOutsideRightClickHandler(event);
        }
      }
    };

    this.addOutsideClickHandler = () => {
      document.body.addEventListener('touchend', this.handleOutsideClick);
      document.body.addEventListener('click', this.handleOutsideClick);
    };

    this.removeOutsideClickHandler = () => {
      document.body.removeEventListener('touchend', this.handleOutsideClick);
      document.body.removeEventListener('click', this.handleOutsideClick);
    };

    this.addOutsideRightClickHandler = () => document.body.addEventListener('contextmenu', this.handleOutsideRightClick);

    this.removeOutsideRightClickHandler = () => document.body.removeEventListener('contextmenu', this.handleOutsideRightClick);

    this.getTooltipRef = node => {
      this.tooltipRef = node;
      setRef(this.props.innerRef, node);
    };

    this.getArrowProps = (props = {}) => _extends({}, props, {
      style: _extends({}, props.style, {}, this.props.arrowProps.style)
    });

    this.getTooltipProps = (props = {}) => _extends({}, props, {}, this.isTriggeredBy('hover') && {
      onMouseEnter: callAll(this.props.clearScheduled, props.onMouseEnter),
      onMouseLeave: callAll(this.props.hideTooltip, props.onMouseLeave)
    }, {
      style: _extends({}, props.style, {}, this.props.style)
    });

    this.contextValue = {
      isParentNoneTriggered: this.props.trigger === 'none',
      addParentOutsideClickHandler: this.addOutsideClickHandler,
      addParentOutsideRightClickHandler: this.addOutsideRightClickHandler,
      parentOutsideClickHandler: this.handleOutsideClick,
      parentOutsideRightClickHandler: this.handleOutsideRightClick,
      removeParentOutsideClickHandler: this.removeOutsideClickHandler,
      removeParentOutsideRightClickHandler: this.removeOutsideRightClickHandler
    };
  }

  componentDidMount() {
    const observer = this.observer = new MutationObserver(() => {
      this.props.scheduleUpdate();
    });
    observer.observe(this.tooltipRef, this.props.mutationObserverOptions);

    if (this.isTriggeredBy('hover') || this.isTriggeredBy('click') || this.isTriggeredBy('right-click')) {
      const _this$context = this.context,
            removeParentOutsideClickHandler = _this$context.removeParentOutsideClickHandler,
            removeParentOutsideRightClickHandler = _this$context.removeParentOutsideRightClickHandler;
      this.addOutsideClickHandler();
      this.addOutsideRightClickHandler();

      if (removeParentOutsideClickHandler) {
        removeParentOutsideClickHandler();
      }

      if (removeParentOutsideRightClickHandler) {
        removeParentOutsideRightClickHandler();
      }
    }
  }

  componentDidUpdate() {
    if (this.props.closeOnOutOfBoundaries && this.props.outOfBoundaries) {
      this.props.hideTooltip();
    }
  }

  componentWillUnmount() {
    if (this.observer) {
      this.observer.disconnect();
    }

    if (this.isTriggeredBy('hover') || this.isTriggeredBy('click') || this.isTriggeredBy('right-click')) {
      const _this$context2 = this.context,
            isParentNoneTriggered = _this$context2.isParentNoneTriggered,
            addParentOutsideClickHandler = _this$context2.addParentOutsideClickHandler,
            addParentOutsideRightClickHandler = _this$context2.addParentOutsideRightClickHandler;
      this.removeOutsideClickHandler();
      this.removeOutsideRightClickHandler();
      this.handleOutsideClick = undefined;
      this.handleOutsideRightClick = undefined;

      if (!isParentNoneTriggered && addParentOutsideClickHandler) {
        addParentOutsideClickHandler();
      }

      if (!isParentNoneTriggered && addParentOutsideRightClickHandler) {
        addParentOutsideRightClickHandler();
      }
    }
  }

  render() {
    const _this$props3 = this.props,
          arrowProps = _this$props3.arrowProps,
          placement = _this$props3.placement,
          tooltip = _this$props3.tooltip;
    return /*#__PURE__*/React.createElement(TooltipContext.Provider, {
      value: this.contextValue
    }, tooltip({
      arrowRef: arrowProps.ref,
      getArrowProps: this.getArrowProps,
      getTooltipProps: this.getTooltipProps,
      placement,
      tooltipRef: this.getTooltipRef
    }));
  }

  isTriggeredBy(event) {
    const trigger = this.props.trigger;
    return trigger === event || Array.isArray(trigger) && trigger.includes(event);
  }

}

Tooltip.contextType = TooltipContext;

const DEFAULT_MODIFIERS = {
  preventOverflow: {
    boundariesElement: 'viewport'
  }
};
const DEFAULT_MUTATION_OBSERVER_CONFIG = {
  childList: true,
  subtree: true
};

class TooltipTrigger extends React.Component {
  constructor(...args) {
    super(...args);
    this.state = {
      tooltipShown: this.props.defaultTooltipShown
    };
    this.hideTimeout = void 0;
    this.showTimeout = void 0;
    this.popperOffset = void 0;

    this.setTooltipState = state => {
      const cb = () => this.props.onVisibilityChange(state.tooltipShown);

      this.isControlled() ? cb() : this.setState(state, cb);
    };

    this.clearScheduled = () => {
      clearTimeout(this.hideTimeout);
      clearTimeout(this.showTimeout);
    };

    this.showTooltip = ({
      pageX,
      pageY
    }) => {
      this.clearScheduled();
      let state = {
        tooltipShown: true
      };

      if (this.props.followCursor) {
        state = _extends({}, state, {
          pageX,
          pageY
        });
      }

      this.showTimeout = window.setTimeout(() => this.setTooltipState(state), this.props.delayShow);
    };

    this.hideTooltip = () => {
      this.clearScheduled();
      this.hideTimeout = window.setTimeout(() => this.setTooltipState({
        tooltipShown: false
      }), this.props.delayHide);
    };

    this.toggleTooltip = ({
      pageX,
      pageY
    }) => {
      const action = this.getState() ? 'hideTooltip' : 'showTooltip';
      this[action]({
        pageX,
        pageY
      });
    };

    this.clickToggle = event => {
      event.preventDefault();
      const pageX = event.pageX,
            pageY = event.pageY;
      const action = this.props.followCursor ? 'showTooltip' : 'toggleTooltip';
      this[action]({
        pageX,
        pageY
      });
    };

    this.contextMenuToggle = event => {
      event.preventDefault();
      const pageX = event.pageX,
            pageY = event.pageY;
      const action = this.props.followCursor ? 'showTooltip' : 'toggleTooltip';
      this[action]({
        pageX,
        pageY
      });
    };

    this.getTriggerProps = (props = {}) => {
      return _extends({}, props, {}, this.isTriggeredBy('click') && {
        onClick: callAll(this.clickToggle, props.onClick),
        onTouchEnd: callAll(this.clickToggle, props.onTouchEnd)
      }, {}, this.isTriggeredBy('right-click') && {
        onContextMenu: callAll(this.contextMenuToggle, props.onContextMenu)
      }, {}, this.isTriggeredBy('hover') && _extends({
        onMouseEnter: callAll(this.showTooltip, props.onMouseEnter),
        onMouseLeave: callAll(this.hideTooltip, props.onMouseLeave)
      }, this.props.followCursor && {
        onMouseMove: callAll(this.showTooltip, props.onMouseMove)
      }), {}, this.isTriggeredBy('focus') && {
        onFocus: callAll(this.showTooltip, props.onFocus),
        onBlur: callAll(this.hideTooltip, props.onBlur)
      });
    };
  }

  componentWillUnmount() {
    this.clearScheduled();
  }

  render() {
    const _this$props = this.props,
          children = _this$props.children,
          tooltip = _this$props.tooltip,
          placement = _this$props.placement,
          trigger = _this$props.trigger,
          getTriggerRef = _this$props.getTriggerRef,
          modifiers = _this$props.modifiers,
          closeOnOutOfBoundaries = _this$props.closeOnOutOfBoundaries,
          usePortal = _this$props.usePortal,
          portalContainer = _this$props.portalContainer,
          followCursor = _this$props.followCursor,
          getTooltipRef = _this$props.getTooltipRef,
          mutationObserverOptions = _this$props.mutationObserverOptions,
          restProps = _objectWithoutPropertiesLoose(_this$props, ["children", "tooltip", "placement", "trigger", "getTriggerRef", "modifiers", "closeOnOutOfBoundaries", "usePortal", "portalContainer", "followCursor", "getTooltipRef", "mutationObserverOptions"]);

    const popper = /*#__PURE__*/React.createElement(reactPopper.Popper, _extends({
      innerRef: getTooltipRef,
      placement: placement,
      modifiers: _extends({}, DEFAULT_MODIFIERS, {}, followCursor && {
        followCursorModifier: {
          enabled: true,
          fn: data => {
            this.popperOffset = data.offsets.popper;
            return data;
          },
          order: 1000
        }
      }, {}, modifiers)
    }, restProps), ({
      ref,
      style,
      // tslint:disable-next-line
      placement,
      arrowProps,
      outOfBoundaries,
      scheduleUpdate
    }) => {
      if (followCursor && this.popperOffset) {
        const _this$state = this.state,
              pageX = _this$state.pageX,
              pageY = _this$state.pageY;
        const _this$popperOffset = this.popperOffset,
              width = _this$popperOffset.width,
              height = _this$popperOffset.height;
        const x = pageX + width > window.scrollX + document.body.offsetWidth ? pageX - width : pageX;
        const y = pageY + height > window.scrollY + document.body.offsetHeight ? pageY - height : pageY;
        style.transform = `translate3d(${x}px, ${y}px, 0`;
      }

      return /*#__PURE__*/React.createElement(Tooltip, _extends({
        arrowProps,
        closeOnOutOfBoundaries,
        outOfBoundaries,
        placement,
        scheduleUpdate,
        style,
        tooltip,
        trigger,
        mutationObserverOptions
      }, {
        clearScheduled: this.clearScheduled,
        hideTooltip: this.hideTooltip,
        innerRef: ref
      }));
    });
    return /*#__PURE__*/React.createElement(reactPopper.Manager, null, /*#__PURE__*/React.createElement(reactPopper.Reference, {
      innerRef: getTriggerRef
    }, ({
      ref
    }) => children({
      getTriggerProps: this.getTriggerProps,
      triggerRef: ref
    })), this.getState() && (usePortal ? reactDom.createPortal(popper, portalContainer) : popper));
  }

  isControlled() {
    return this.props.tooltipShown !== undefined;
  }

  getState() {
    return this.isControlled() ? this.props.tooltipShown : this.state.tooltipShown;
  }

  isTriggeredBy(event) {
    const trigger = this.props.trigger;
    return trigger === event || Array.isArray(trigger) && trigger.includes(event);
  }

}

TooltipTrigger.defaultProps = {
  closeOnOutOfBoundaries: true,
  defaultTooltipShown: false,
  delayHide: 0,
  delayShow: 0,
  followCursor: false,
  onVisibilityChange: noop,
  placement: 'right',
  portalContainer: canUseDOM() ? document.body : null,
  trigger: 'hover',
  usePortal: canUseDOM(),
  mutationObserverOptions: DEFAULT_MUTATION_OBSERVER_CONFIG
};

module.exports = TooltipTrigger;
//# sourceMappingURL=react-popper-tooltip.js.map
