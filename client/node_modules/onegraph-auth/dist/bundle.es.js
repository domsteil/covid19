function __$$styleInject(css, ref) {
  if ( ref === void 0 ) ref = {};
  var insertAt = ref.insertAt;

  if (!css || typeof document === 'undefined') { return; }

  var head = document.head || document.getElementsByTagName('head')[0];
  var style = document.createElement('style');
  style.type = 'text/css';

  if (insertAt === 'top') {
    if (head.firstChild) {
      head.insertBefore(style, head.firstChild);
    } else {
      head.appendChild(style);
    }
  } else {
    head.appendChild(style);
  }

  if (style.styleSheet) {
    style.styleSheet.cssText = css;
  } else {
    style.appendChild(document.createTextNode(css));
  }
}

function OAuthError(errorObject, fileName, lineNumber) {
  var message = "OAuthError: " + errorObject.error + " " + errorObject.error_description;
  var instance = new Error(message, fileName, lineNumber);
  instance.oauthError = errorObject;
  Object.setPrototypeOf(instance, Object.getPrototypeOf(this));
  if (Error.captureStackTrace) {
    Error.captureStackTrace(instance, OAuthError);
  }
  return instance;
}

OAuthError.prototype = Object.create(Error.prototype, {
  constructor: {
    value: Error,
    enumerable: false,
    writable: true,
    configurable: true
  }
});

if (Object.setPrototypeOf) {
  Object.setPrototypeOf(OAuthError, Error);
} else {
  OAuthError.__proto__ = Error;
}

var classCallCheck = function (instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
};

var createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);
    if (staticProps) defineProperties(Constructor, staticProps);
    return Constructor;
  };
}();







var _extends = Object.assign || function (target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i];

    for (var key in source) {
      if (Object.prototype.hasOwnProperty.call(source, key)) {
        target[key] = source[key];
      }
    }
  }

  return target;
};













var objectWithoutProperties = function (obj, keys) {
  var target = {};

  for (var i in obj) {
    if (keys.indexOf(i) >= 0) continue;
    if (!Object.prototype.hasOwnProperty.call(obj, i)) continue;
    target[i] = obj[i];
  }

  return target;
};







var slicedToArray = function () {
  function sliceIterator(arr, i) {
    var _arr = [];
    var _n = true;
    var _d = false;
    var _e = undefined;

    try {
      for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
        _arr.push(_s.value);

        if (i && _arr.length === i) break;
      }
    } catch (err) {
      _d = true;
      _e = err;
    } finally {
      try {
        if (!_n && _i["return"]) _i["return"]();
      } finally {
        if (_d) throw _e;
      }
    }

    return _arr;
  }

  return function (arr, i) {
    if (Array.isArray(arr)) {
      return arr;
    } else if (Symbol.iterator in Object(arr)) {
      return sliceIterator(arr, i);
    } else {
      throw new TypeError("Invalid attempt to destructure non-iterable instance");
    }
  };
}();













var toConsumableArray = function (arr) {
  if (Array.isArray(arr)) {
    for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];

    return arr2;
  } else {
    return Array.from(arr);
  }
};

var InMemoryStorage = function InMemoryStorage() {
  var _this = this;

  classCallCheck(this, InMemoryStorage);
  this.state = {};

  this.getItem = function (key) {
    return _this.state[key];
  };

  this.setItem = function (key, value) {
    _this.state[key] = value;
  };

  this.removeItem = function (key) {
    delete _this.state[key];
  };
};

var OG_PREFIX = 'oneGraph:';

var LocalStorage = function () {
  function LocalStorage() {
    classCallCheck(this, LocalStorage);
  }

  createClass(LocalStorage, [{
    key: 'getItem',
    value: function getItem(key) {
      return localStorage.getItem(OG_PREFIX + key);
    }
  }, {
    key: 'setItem',
    value: function setItem(key, value) {
      return localStorage.setItem(OG_PREFIX + key, value);
    }
  }, {
    key: 'removeItem',
    value: function removeItem(key) {
      return localStorage.removeItem(OG_PREFIX + key);
    }
  }]);
  return LocalStorage;
}();

var DEBUG_KEY = '__og_debug';

function hasLocalStorage() {
  try {
    localStorage.setItem(DEBUG_KEY, 'debug');
    localStorage.removeItem(DEBUG_KEY);
    return true;
  } catch (e) {
    return (
      // $FlowFixMe
      e instanceof DOMException && (
      // everything except Firefox
      e.code === 22 ||
      // Firefox
      e.code === 1014 ||
      // test name field too, because code might not be present
      // everything except Firefox
      e.name === 'QuotaExceededError' ||
      // Firefox
      e.name === 'NS_ERROR_DOM_QUOTA_REACHED') &&
      // acknowledge QuotaExceededError only if there's something already stored
      localStorage.length !== 0
    );
  }
}

var URI_REGEX = new RegExp(['^(https?://[^:/?#]*(?::[0-9]+)?)', // origin
'(/{0,1}[^?#]*)', // path
'(\\?[^#]*|)', // search
'(#.*|)$'].join(''));

function parseQuery(queryString) {
  return queryString.split(/[?&]/).reduce(function (query, part) {
    var _part$split = part.split('='),
        _part$split2 = slicedToArray(_part$split, 2),
        param = _part$split2[0],
        value = _part$split2[1];

    if (param != null && value != null) {
      query[param] = value;
    }
    return query;
  }, {});
}

function parse(uriString) {
  var match = uriString.match(URI_REGEX);
  if (!match) {
    throw new Error('invalid url ' + uriString);
  }
  return {
    origin: match[1],
    path: match[2],
    query: parseQuery(match[3])
  };
}

function safeParse(uriString) {
  try {
    return parse(uriString);
  } catch (e) {
    return null;
  }
}

function addQueryParams(uri, query) {
  return _extends({}, uri, {
    query: _extends({}, uri.query, query)
  });
}

function setPath(uri, path) {
  return _extends({}, uri, {
    path: path
  });
}

function queryToString(query) {
  return Object.keys(query).map(function (k) {
    return k + '=' + query[k];
  }).join('&');
}

function toString(uri) {
  var origin = uri.origin,
      path = uri.path,
      query = uri.query;

  var queryString = queryToString(query);
  return origin + path + (queryString ? '?' + queryString : '');
}

function make(_ref) {
  var origin = _ref.origin,
      path = _ref.path,
      query = _ref.query;

  var uri = parse(origin);
  uri = setPath(uri, path);
  uri = addQueryParams(uri, query);
  return uri;
}

var URI = {
  parse: parse,
  safeParse: safeParse,
  addQueryParams: addQueryParams,
  setPath: setPath,
  toString: toString,
  make: make,
  queryToString: queryToString
};

// $FlowFixMe


var POLL_INTERVAL = 35;

var ALL_SERVICES = ['box', 'dribbble', 'dropbox', 'eventil', 'facebook', 'github', 'gmail', 'google', 'google-calendar', 'google-compute', 'google-docs', 'google-translate', 'hubspot', 'intercom', 'quickbooks', 'salesforce', 'slack', 'spotify', 'stripe', 'trello', 'twilio', 'twitter', 'youtube', 'zeit', 'zendesk'];

function _friendlyServiceName(service) {
  switch (service) {
    case 'box':
      return 'Box';
    case 'dribbble':
      return 'Dribbble';
    case 'dropbox':
      return 'Dropbox';
    case 'eventil':
      return 'Eventil';
    case 'facebook':
      return 'Facebook';
    case 'github':
      return 'GitHub';
    case 'gmail':
      return 'Gmail';
    case 'google':
      return 'Google';
    case 'google-calendar':
      return 'Google Calendar';
    case 'google-compute':
      return 'Google Compute';
    case 'google-docs':
      return 'Google Docs';
    case 'google-translate':
      return 'Google Translate';
    case 'hubspot':
      return 'HubSpot';
    case 'intercom':
      return 'Intercom';
    case 'quickbooks':
      return 'Quickbooks';
    case 'salesforce':
      return 'Salesforce';
    case 'slack':
      return 'Slack';
    case 'spotify':
      return 'Spotify';
    case 'stripe':
      return 'Stripe';
    case 'trello':
      return 'Trello';
    case 'twilio':
      return 'Twilio';
    case 'twitter':
      return 'Twitter';
    case 'youtube':
      return 'YouTube';
    case 'zeit':
      return 'Zeit';
    case 'zendesk':
      return 'Zendesk';
    default:
       // exhaustive switch check from flow
      return service;
  }
}

function getWindowOpts() {
  var windowWidth = Math.min(800, Math.floor(window.outerWidth * 0.8));
  var windowHeight = Math.min(630, Math.floor(window.outerHeight * 0.5));
  var windowArea = {
    width: windowWidth,
    height: windowHeight,
    left: Math.round(window.screenX + (window.outerWidth - windowWidth) / 2),
    top: Math.round(window.screenY + (window.outerHeight - windowHeight) / 8)
  };

  // TODO: figure out how to show the toolbar icons in the window for password managers
  return {
    width: windowArea.width,
    height: windowArea.height,
    left: windowArea.left,
    top: windowArea.top,
    toolbar: 0,
    scrollbars: 1,
    status: 1,
    resizable: 1,
    menuBar: 0
  };
}

function createAuthWindow(authUrlString, service, stateParam, scopes) {
  var windowOpts = getWindowOpts();
  var authUrl = URI.addQueryParams(URI.parse(authUrlString), _extends({
    state: stateParam
  }, scopes ? { scopes: scopes.join(',') } : {}));
  return window.open(URI.toString(authUrl), 'Log in with ' + _friendlyServiceName(service), Object.keys(windowOpts).map(function (k) {
    return k + '=' + windowOpts[k];
  }).join(','));
}

// Cycles path through URL.origin to ensure that it's the same format we'll
// see in the auth window's location
function normalizeRedirectOrigin(origin) {
  return URI.parse(origin).origin;
}

// Cycles path through URL.pathname to ensure that it's the same format we'll
// see in the auth window's location
function normalizeRedirectPath(path) {
  return path === '/' ? '' : path;
}

var loggedInQuery = '\nquery LoggedInQuery {\n  me {\n    serviceMetadata {\n      loggedInServices {\n        service\n        foreignUserId\n      }\n    }\n  }\n}\n';

var allServicesQuery = '\nquery AllServicesQuery {\n  oneGraph {\n    services(filter: {supportsOauthLogin: true}) {\n      service\n      friendlyServiceName\n    }\n  }\n}\n';

function getServiceEnum(service) {
  return service.toUpperCase().replace(/-/, '_');
}

function fromServiceEnum(serviceEnum) {
  return serviceEnum.toLowerCase().replace(/_/, '-');
}

function getIsLoggedIn(queryResult, service, foreignUserId) {
  var _ref;

  var serviceEnum = getServiceEnum(service);
  var loggedInServices = ((_ref = queryResult) != null ? (_ref = _ref.data) != null ? (_ref = _ref.me) != null ? (_ref = _ref.serviceMetadata) != null ? _ref.loggedInServices : _ref : _ref : _ref : _ref) || [];
  return !!loggedInServices.find(function (serviceInfo) {
    return serviceInfo.service === serviceEnum && (!foreignUserId || foreignUserId === serviceInfo.foreignUserId);
  });
}

function getServiceErrors(errors, service) {
  return errors.filter(function (error) {
    return error.path && error.path.includes(service);
  });
}

var logoutMutation = 'mutation SignOutServicesMutation(\n  $services: [OneGraphServiceEnum!]!\n) {\n  signoutServices(data: { services: $services }) {\n    me {\n      serviceMetadata {\n        loggedInServices {\n          service\n          foreignUserId\n        }\n      }\n    }\n  }\n}';

var logoutUserMutation = 'mutation SignOutServicesMutation(\n  $service: OneGraphServiceEnum!\n  $foreignUserId: String!\n) {\n  signoutServiceUser(\n    input: {\n      service: $service\n      foreignUserId: $foreignUserId\n    }\n  ) {\n    me {\n      serviceMetadata {\n        loggedInServices {\n          service\n          foreignUserId\n        }\n      }\n    }\n  }\n}';

function fetchQuery(fetchUrl, query, variables, token) {
  return fetch(fetchUrl, {
    method: 'POST',
    headers: _extends({
      'Content-Type': 'application/json',
      Accept: 'application/json'
    }, token ? { Authorization: 'Bearer ' + token.accessToken } : {}),
    body: JSON.stringify({ query: query, variables: variables })
  }).then(function (response) {
    return response.json();
  });
}

function exchangeCode(oneGraphOrigin, appId, redirectOrigin, redirectPath, code, token) {
  var redirectUri = redirectOrigin + redirectPath;
  var url = URI.make({
    origin: oneGraphOrigin,
    path: '/oauth/code',
    query: {
      app_id: appId,
      redirect_uri: redirectUri,
      code: code
    }
  });
  var headers = _extends({
    'Content-Type': 'application/json',
    Accept: 'application/json'
  }, token ? { Authorization: 'Bearer ' + token.accessToken } : {});
  return fetch(URI.toString(url), {
    method: 'POST',
    headers: headers
  }).then(function (response) {
    return response.json();
  });
}

function exchangeRefreshToken(oneGraphOrigin, appId, refreshToken) {
  var url = URI.make({
    origin: oneGraphOrigin,
    path: '/oauth/token',
    query: {
      app_id: appId
    }
  });
  var headers = {
    'Content-Type': 'application/x-www-form-urlencoded',
    accept: 'application/json'
  };
  return fetch(URI.toString(url), {
    method: 'POST',
    headers: headers,
    body: URI.queryToString({
      grant_type: 'refresh_token',
      refresh_token: refreshToken
    })
  }).then(function (response) {
    return response.json();
  });
}

function byteArrayToString(byteArray) {
  return byteArray.reduce(function (acc, byte) {
    return acc + (byte & 0xff).toString(16).slice(-2);
  }, '');
}

function makeStateParam() {
  return byteArrayToString(window.crypto.getRandomValues(new Uint8Array(32)));
}

function isExpired(token) {
  return token.expireDate < Date.now();
}

function tokenFromStorage(storage, appId) {
  var v = storage.getItem(appId);
  if (v) {
    var possibleToken = JSON.parse(v);
    if (typeof possibleToken.accessToken === 'string' && typeof possibleToken.expireDate === 'number' && !isExpired(possibleToken)) {
      return possibleToken;
    }
  }
  return null;
}

function findMissingAuthServices(results) {
  /* Detect and normalize between:
  1. The full graphql result
  2. The `result.errors` of a graphql result
  3. Apollo's GraphQL error structure
   */
  var errors = results && (
  // Full GraphQL result
  results.errors ||
  // Apollo error
  results.graphQLErrors ||
  // Possibly result.errors
  results);

  // If errors aren't an array, bail
  if (!Array.isArray(errors)) {
    return [];
  }

  var missingServiceErrors = errors.filter(function (error) {
    var _ref2;

    return ((_ref2 = error) != null ? (_ref2 = _ref2.extensions) != null ? _ref2.type : _ref2 : _ref2) === 'auth/missing-auth';
  });

  var missingServices = missingServiceErrors.map(function (error) {
    var _ref3;

    return (_ref3 = error) != null ? (_ref3 = _ref3.extensions) != null ? _ref3.service : _ref3 : _ref3;
  }).filter(Boolean);

  return missingServices;
}

var DEFAULT_ONEGRAPH_ORIGIN = 'https://serve.onegraph.com';

var OneGraphAuth = function () {
  function OneGraphAuth(opts) {
    var _this = this;

    classCallCheck(this, OneGraphAuth);
    this._authWindows = {};
    this._intervalIds = {};
    this._messageListeners = {};
    this._accessToken = null;
    this.supportedServices = ALL_SERVICES;

    this._clearInterval = function (service) {
      clearInterval(_this._intervalIds[service]);
      delete _this._intervalIds[service];
    };

    this._clearMessageListener = function (service) {
      window.removeEventListener('message', _this._messageListeners[service], false);
      delete _this._messageListeners[service];
    };

    this._clearAuthWindow = function (service) {
      var w = _this._authWindows[service];
      w && w.close();
      delete _this._authWindows[service];
    };

    this.cleanup = function (service) {
      _this._clearInterval(service);
      _this._clearMessageListener(service);
      _this._clearAuthWindow(service);
    };

    this.accessToken = function () {
      return _this._accessToken;
    };

    this.tokenExpireDate = function () {
      if (!_this._accessToken) {
        return null;
      }
      return new Date(_this._accessToken.expireDate);
    };

    this.tokenExpiresSecondsFromNow = function () {
      var expireDate = _this.tokenExpireDate();
      if (!expireDate) {
        return null;
      }
      var seconds = expireDate - new Date();
      if (seconds < 0) {
        return null;
      }
      return Math.floor(seconds / 1000);
    };

    this.refreshToken = function (refreshToken) {
      return exchangeRefreshToken(_this.oneGraphOrigin, _this.appId, refreshToken).then(function (response) {
        if (!response) {
          throw new OAuthError({
            error: 'invalid_grant',
            error_description: 'Invalid response refreshing token.'
          });
        }
        if (response.error) {
          throw new OAuthError({
            error: response.error,
            error_description: response.error_description
          });
        }
        if (!response.access_token || !response.expires_in || !response.refresh_token) {
          throw new OAuthError({
            error: 'invalid_grant',
            error_description: 'Inavlid response from server while refreshing token.'
          });
        } else {
          var _token = {
            accessToken: response.access_token,
            expireDate: Date.now() + response.expires_in * 1000,
            refreshToken: response.refresh_token
          };
          _this.setToken(_token);
          return _token;
        }
      });
    };

    this.authHeaders = function () {
      if (_this._accessToken) {
        return { Authorization: 'Bearer ' + _this._accessToken.accessToken };
      } else {
        return {};
      }
    };

    this._makeAuthUrl = function (service) {
      var authUrl = URI.make({
        origin: _this.oneGraphOrigin,
        path: '/oauth/start',
        query: {
          service: service,
          app_id: _this.appId,
          response_type: 'code',
          redirect_origin: _this._redirectOrigin,
          redirect_path: _this._redirectPath,
          communication_mode: _this._communicationMode
        }
      });
      return URI.toString(authUrl);
    };

    this.setToken = function (token) {
      _this._accessToken = token;
      var refreshToken = token.refreshToken,
          storableToken = objectWithoutProperties(token, ['refreshToken']);

      _this._storage.setItem(_this._storageKey, JSON.stringify(storableToken));
    };

    this._waitForAuthFinishPostMessage = function (service, stateParam) {
      var postMessageOrigin = normalizeRedirectOrigin(_this.oneGraphOrigin);
      return new Promise(function (resolve, reject) {
        var listener = function listener(event) {
          if (normalizeRedirectOrigin(event.origin) !== postMessageOrigin) {
            console.warn('ignoring event for origin', event.origin, 'expected', postMessageOrigin);
          } else {
            var message = JSON.parse(event.data);
            if (message && message.version === 1) {
              var code = message.code,
                  state = message.state;

              if (state !== stateParam) {
                console.warn('Invalid state param, skipping');
              } else {
                if (!code) {
                  reject(new OAuthError({
                    error: 'invalid_grant',
                    error_description: 'Missing code'
                  }));
                } else {
                  exchangeCode(_this.oneGraphOrigin, _this.appId, _this._redirectOrigin, _this._redirectPath, code, _this._accessToken).then(function (response) {
                    if (response.error) {
                      reject(new OAuthError(response));
                    } else if (typeof response.access_token === 'string' && typeof response.expires_in === 'number') {
                      var _token2 = {
                        accessToken: response.access_token,
                        expireDate: Date.now() + response.expires_in * 1000,
                        refreshToken: response.refresh_token
                      };
                      _this.setToken(_token2);
                      resolve({
                        token: _token2,
                        service: response.service,
                        foreignUserId: response.foreign_user_id
                      });
                    } else {
                      reject(new Error('Unexpected result from server'));
                    }
                  }).catch(function (e) {
                    return reject(e);
                  });
                }
              }
            }
          }
        };
        _this._messageListeners[service] = listener;
        window.addEventListener('message', listener, false);
      });
    };

    this._waitForAuthFinishRedirect = function (service, stateParam) {
      return new Promise(function (resolve, reject) {
        _this._intervalIds[service] = setInterval(function () {
          try {
            var authUri = URI.safeParse(_this._authWindows[service].location.toString());
            if (authUri && authUri.origin === _this._redirectOrigin) {
              var params = authUri.query;
              if (stateParam !== params.state) {
                reject(new OAuthError({
                  error: 'invalid_request',
                  error_description: 'The state param does not match'
                }));
              } else {
                var code = params.code;
                if (!code) {
                  reject(new OAuthError({
                    error: 'invalid_grant',
                    error_description: 'Missing code'
                  }));
                } else {
                  exchangeCode(_this.oneGraphOrigin, _this.appId, _this._redirectOrigin, _this._redirectPath, code, _this._accessToken).then(function (response) {
                    if (response.error) {
                      reject(new OAuthError(response));
                    } else if (typeof response.access_token === 'string' && typeof response.expires_in === 'number') {
                      var _token3 = {
                        accessToken: response.access_token,
                        expireDate: Date.now() + response.expires_in * 1000,
                        refreshToken: response.refresh_token
                      };
                      _this.setToken(_token3);
                      resolve({ token: _token3 });
                    } else {
                      reject(new Error('Unexpected result from server'));
                    }
                  }).catch(function (e) {
                    return reject(e);
                  });
                }
              }
            }
          } catch (e) {
            if (e instanceof window.DOMException) {
              // do nothing--probably on the service's or onegraph's domain
            } else {
              console.error('unexpected error waiting for auth to finish for ' + service, e);
              reject(e);
            }
          }
        }, POLL_INTERVAL);
      });
    };

    this.login = function (service, scopes) {
      if (!service) {
        throw new Error("Missing required argument. Provide service as first argument to login (e.g. `auth.login('stripe')`).");
      }
      _this.cleanup(service);
      var stateParam = makeStateParam();
      _this._authWindows[service] = createAuthWindow(_this._makeAuthUrl(service), service, stateParam, scopes);
      var authFinish = _this._communicationMode === 'redirect' ? _this._waitForAuthFinishRedirect : _this._waitForAuthFinishPostMessage;
      return authFinish(service, stateParam).then(function (result) {
        _this.cleanup(service);
        return result;
      }).catch(function (e) {
        _this.cleanup(service);
        throw e;
      });
    };

    this.isLoggedIn = function (args) {
      var accessToken = _this._accessToken;
      if (accessToken) {
        var _service = typeof args === 'string' ? args : args.service;
        if (!_service) {
          throw new Error("Missing required argument. Provide service as first argument to isLoggedIn (e.g. `auth.isLoggedIn('stripe')`).");
        }
        var _foreignUserId = typeof args === 'string' ? null : args.foreignUserId;
        return fetchQuery(_this._fetchUrl, loggedInQuery, {}, accessToken).then(function (result) {
          return getIsLoggedIn(result, _service, _foreignUserId);
        });
      } else {
        return Promise.resolve(false);
      }
    };

    this.servicesStatus = function () {
      var accessToken = _this._accessToken;
      if (accessToken) {
        return fetchQuery(_this._fetchUrl, loggedInQuery, {}, accessToken).then(function (result) {
          return ALL_SERVICES.reduce(function (acc, service) {
            acc[service] = { isLoggedIn: getIsLoggedIn(result, service) };
            return acc;
          }, {});
        });
      } else {
        return Promise.resolve(ALL_SERVICES.reduce(function (acc, service) {
          acc[service] = { isLoggedIn: false };
          return acc;
        }, {}));
      }
    };

    this.allServices = function () {
      return fetchQuery(_this._fetchUrl, allServicesQuery, {}, null).then(function (result) {
        return result.data.oneGraph.services.map(function (serviceInfo) {
          return {
            serviceEnum: serviceInfo.service,
            service: fromServiceEnum(serviceInfo.service),
            friendlyServiceName: serviceInfo.friendlyServiceName
          };
        });
      });
    };

    this.loggedInServices = function () {
      var accessToken = _this._accessToken;
      if (accessToken) {
        return fetchQuery(_this._fetchUrl, loggedInQuery, {}, accessToken).then(function (result) {
          var _ref4;

          var loggedInServices = ((_ref4 = result) != null ? (_ref4 = _ref4.data) != null ? (_ref4 = _ref4.me) != null ? (_ref4 = _ref4.serviceMetadata) != null ? _ref4.loggedInServices : _ref4 : _ref4 : _ref4 : _ref4) || [];
          return loggedInServices.reduce(function (acc, serviceInfo) {
            var serviceKey = fromServiceEnum(serviceInfo.service);
            var loggedInInfo = acc[serviceKey] || {
              serviceEnum: serviceInfo.service,
              foreignUserIds: []
            };
            acc[serviceKey] = _extends({}, loggedInInfo, {
              foreignUserIds: [serviceInfo.foreignUserId].concat(toConsumableArray(loggedInInfo.foreignUserIds))
            });
            return acc;
          }, {});
        });
      } else {
        return Promise.resolve({});
      }
    };

    this.logout = function (service, foreignUserId) {
      if (!service) {
        throw new Error("Missing required argument. Provide service as first argument to logout (e.g. `auth.logout('stripe')`).");
      }
      _this.cleanup(service);
      var accessToken = _this._accessToken;
      if (accessToken) {
        var _serviceEnum = getServiceEnum(service);

        var signoutPromise = foreignUserId ? fetchQuery(_this._fetchUrl, logoutUserMutation, {
          service: _serviceEnum,
          foreignUserId: foreignUserId
        }, accessToken) : fetchQuery(_this._fetchUrl, logoutMutation, {
          services: [_serviceEnum]
        }, accessToken);
        return signoutPromise.then(function (result) {
          if (result.errors && result.errors.length && getServiceErrors(result.errors).length) {
            return { result: 'failure', errors: result.errors };
          } else {
            var loggedIn = getIsLoggedIn({ data: result.signoutServices }, service, foreignUserId);
            return { result: loggedIn ? 'failure' : 'success' };
          }
        });
      } else {
        return Promise.resolve({ result: 'failure' });
      }
    };

    this.destroy = function () {
      Object.keys(_this._intervalIds).forEach(function (key) {
        return _this.cleanup(key);
      });
      Object.keys(_this._authWindows).forEach(function (key) {
        return _this.cleanup(key);
      });
      _this._storage.removeItem(_this._storageKey);
      _this._accessToken = null;
    };

    this.findMissingAuthServices = findMissingAuthServices;
    var appId = opts.appId,
        oauthFinishOrigin = opts.oauthFinishOrigin,
        oauthFinishPath = opts.oauthFinishPath;

    this.oneGraphOrigin = opts.oneGraphOrigin || DEFAULT_ONEGRAPH_ORIGIN;
    this.appId = appId;
    var windowUri = URI.parse(window.location.toString());
    this._redirectOrigin = normalizeRedirectOrigin(oauthFinishOrigin || windowUri.origin);
    if (this._redirectOrigin !== windowUri.origin) {
      console.warn('oauthFinishOrigin does not match window.location.origin');
    }
    this._redirectPath = normalizeRedirectPath(oauthFinishPath || windowUri.path);

    var fetchUrl = URI.make({
      origin: opts.oneGraphOrigin || DEFAULT_ONEGRAPH_ORIGIN,
      path: '/dynamic',
      query: { app_id: appId }
    });
    this._fetchUrl = opts.graphqlUrl || URI.toString(fetchUrl);
    this._storage = opts.storage || (hasLocalStorage() ? new LocalStorage() : new InMemoryStorage());
    this._storageKey = this.appId;
    this._accessToken = tokenFromStorage(this._storage, this._storageKey);
    this._communicationMode = opts.communicationMode || 'post_message';
  }

  createClass(OneGraphAuth, [{
    key: 'friendlyServiceName',
    value: function friendlyServiceName(service) {
      return _friendlyServiceName(service);
    }
  }]);
  return OneGraphAuth;
}();

export default OneGraphAuth;
export { OneGraphAuth, InMemoryStorage, LocalStorage };
//# sourceMappingURL=bundle.es.js.map
